import {Canister, Err, ic, None, Ok, Principal, query, Result, Some, StableBTreeMap, text, update, Vec} from 'azle'

import {v4 as uuidV4} from 'uuid'
import {Error, Job, JobPayload, User, UserPayload} from "./types";

const jobs = StableBTreeMap(text, Job, 0)
const users = StableBTreeMap(Principal, User, 1)


// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
    return str.trim().length == 0
  }

 // Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
    const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
    return regexExp.test(id);
}


/**
 * Helper function to validate the UserPayload
 * Ensures the following conditions are met:
 * 1. The name is not empty
 * 2. The username is not empty
 * 3. The email is provided in the valid format e.g test@gmail.com
 * 4. The phone number is provided in the valid fornat e.g +2301234567 or 2301234567
 */
function validateUserPayload(payload: typeof UserPayload): Vec<string>{
    const errors: Vec<string> = [];

    const emailRegex = /^\S+@\S+\.\S+$/;
    const phoneRegex = /^\+?\d{1,4}?[-.\s]?\(?\d{1,3}?\)?[-.\s]?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}$/;

    if (isInvalidString(payload.name)){
        errors.push(`name='${payload.name}' cannot be empty.`)
    }
    if (isInvalidString(payload.username)){
        errors.push(`username='${payload.username}' cannot be empty.`)
    }
    if (!emailRegex.test(payload.email)){
        errors.push(`Email='${payload.email}' is invalid.`)
    }
    if (!phoneRegex.test(payload.phone)){
        errors.push(`Phone number='${payload.phone}' is invalid.`)
    }
  
    return errors;
  }

/**
 * Helper function to validate the JobPayload
 * Ensures the following conditions are met:
 * 1. The title is not empty
 * 2. The description is not empty
 */
function validateJobPayload(payload: typeof JobPayload): Vec<string>{
    const errors: Vec<string> = [];

    if (isInvalidString(payload.title)){
        errors.push(`title='${payload.title}' cannot be empty.`)
    }
    if (isInvalidString(payload.description)){
        errors.push(`.description='${payload.description}' cannot be empty.`)
    }
    return errors;
  }
export default Canister({
    /**
     * Creates a new user.
     * @param UserPayload - Contain all the user payload.
     * @returns the newly created user instance.
     */
    registerUser: update([UserPayload], Result(User, Error), (payload) => {
        if (users.containsKey(ic.caller())){
            return Err({DuplicateUser: 'Caller is already a user.'})
        }
        const validatePayloadErrors = validateUserPayload(payload);
        if (validatePayloadErrors.length){
            return Err({InvalidPayload: `Invalid payload. Errors=[${validatePayloadErrors}]`});
        }
        const newUser: typeof User = {
            id: ic.caller(),
            createdAt: ic.time(),
            updatedAt: None,
            isLogged: false,
            ...payload
        }
        users.insert(newUser.id, newUser)
        return Ok(newUser)
    }),

    /**
     * authenticate user.
     * @param text - Contain user username.
     * @param text - Contain user password.
     * @returns success login message.
     */
    loginUser: update(
        [],
        Result(text, Error),
        () => {
            if (!users.containsKey(ic.caller())){
                return Err({NotFound: 'Caller needs to register first.'})
            }
            const user : typeof User= users.get(ic.caller()).Some;
            if (user.isLogged){
                return Err({AuthenticationError: "User is already logged in"})
            }
            user.isLogged = true;
            users.insert(user.id, user)
            return Ok(`Logged in as ${user.username}`)
        }
    ),

    /**
     * logout user.
     * @returns success logout message.
     */
    logOut: update([], Result(text, Error), () => {
        if (!users.containsKey(ic.caller())){
            return Err({NotFound: 'Caller needs to register first.'})
        }
        const user : typeof User= users.get(ic.caller()).Some;
        if (!user.isLogged){
            return Err({AuthenticationError: "User isn't logged in"})
        }
        user.isLogged = false;
        users.insert(user.id, user)
        return Ok('Logged out successfully.')
    }),

    /**
     * get current user profile.
     * @returns current user username.
     */
    getCurrentUser: query([], Result(text, Error), () => {
        if (!users.containsKey(ic.caller())){
            return Err({NotFound: 'Caller needs to register first.'})
        }
        const user : typeof User= users.get(ic.caller()).Some;
        return Ok(user.username)
    }),

    /**
     * Creates a new job.
     * @param JobPayload - Contain all the job payload.
     * @returns the newly created job instance.
     */
    storeJob: update([JobPayload], Result(Job, Error), (payload) => {
        if (!users.containsKey(ic.caller())){
            return Err({NotFound: 'Caller needs to register first.'})
        }
        const user : typeof User= users.get(ic.caller()).Some;
        if (!user.isLogged){
            return Err({AuthenticationError: "User isn't logged in"})
        }

        const validatePayloadErrors = validateJobPayload(payload);
        if (validatePayloadErrors.length){
            return Err({InvalidPayload: `Invalid payload. Errors=[${validatePayloadErrors}]`});
        }
        const job: typeof Job = {
            id: uuidV4(),
            authorId: user.id,
            applies: [],
            applyCount: BigInt(0),
            createdAt: ic.time(),
            updatedAt: None,
            authorName: user.name,
            authorPhone: user.phone,
            authorEmail: user.email,
            ...payload
        }

        jobs.insert(job.id, job)

        return Ok(job)
    }),
    /**
     * Fetch all jobs.
     * @returns a list of all jobs.
     */
    indexJob: query([], Result(Vec(Job), Error), () => {
        return Ok(jobs.values())
    }),
    /**
     * Fetch job by id.
     * @param id - ID of the job.
     * @returns a job instance if exists or an error if job doesn't exist.
     */
    showJob: query([text], Result(Job, Error), (id) => {
        if (!isValidUuid(id)){
            return Err({InvalidPayload: `id=${id} is not in the valid uuid format`})
        }
        const jobData = jobs.get(id)

        if ('None' in jobData) {
            return Err({NotFound: `cannot find job with ${id} id`})
        }

        const job = jobData.Some

        return Ok(job)
    }),
    /**
     * Fetch job by id and update it.
     * @param id - ID of the job.
     * @param JobPayload - Contain all the job payload.
     * @returns a job instance if exists or an error if job doesn't exist.
     */
    updateJob: update([text, JobPayload], Result(Job, Error), (id, payload) => {
        if (!isValidUuid(id)){
            return Err({InvalidPayload: `id=${id} is not in the valid uuid format`})
        }
        if (!users.containsKey(ic.caller())){
            return Err({NotFound: 'Caller needs to register first.'})
        }
        const user : typeof User= users.get(ic.caller()).Some;
        if (!user.isLogged){
            return Err({AuthenticationError: "User isn't logged in"})
        }

        const jobData = jobs.get(id);

        if ('None' in jobData) {
            return Err({NotFound: `cannot find job with ${id} id`})
        }

        const job = jobData.Some

        if (job.authorId.toString() !== user.id.toString()) {
            return Err({AuthenticationError: `you are not this job owner.`})
        }
        const validatePayloadErrors = validateJobPayload(payload);
        if (validatePayloadErrors.length){
            return Err({InvalidPayload: `Invalid payload. Errors=[${validatePayloadErrors}]`});
        }

        const updatedJob = {...job, ...payload, updatedAt: Some(ic.time())}
        jobs.insert(job.id, updatedJob)
        return Ok(updatedJob)
    }),
    /**
     * Fetch job by id and update it.
     * @param id - ID of the job.
     * @param JobPayload - Contain all the job payload.
     * @returns a job instance if exists or an error if job doesn't exist.
     */
    deleteJob: update([text], Result(Job, Error), (id) => {
        if (!isValidUuid(id)){
            return Err({InvalidPayload: `id=${id} is not in the valid uuid format`})
        }
        if (!users.containsKey(ic.caller())){
            return Err({NotFound: 'Caller needs to register first.'})
        }
        const user : typeof User= users.get(ic.caller()).Some;
        if (!user.isLogged){
            return Err({AuthenticationError: "User isn't logged in"})
        }

        const jobData = jobs.get(id);

        if ('None' in jobData) {
            return Err({NotFound: `cannot delete job with ${id} id`})
        }

        const job = jobData.Some

        if (job.authorId.toString() !== user.id.toString()) {
            return Err({AuthenticationError: `you are not this job owner.`})
        }

        const deletedJob = jobs.remove(id);

        return Ok(deletedJob.Some)
    }),
    /**
     * User can apply to a job.
     * @param id - ID of the job.
     * @returns a job instance if exists or an error if job doesn't exist.
     */
    applyJob: update([text], Result(Job, Error), (id) => {
        if (!isValidUuid(id)){
            return Err({InvalidPayload: `id=${id} is not in the valid uuid format`})
        }
        if (!users.containsKey(ic.caller())){
            return Err({NotFound: 'Caller needs to register first.'})
        }
        const user : typeof User= users.get(ic.caller()).Some;
        if (!user.isLogged){
            return Err({AuthenticationError: "User isn't logged in"})
        }

        const jobData = jobs.get(id);

        const job : typeof Job = jobData.Some

        if (job.authorId.toString() === user.id.toString()) {
            return Err({AuthenticationError: `you can't apply in your own job posted.`})
        }

        const isApply = job.applies.filter((apply: Principal)=> apply.toString() === user?.id.toString());

        if (isApply.length > 0) {
            return Err({DuplicateUser: `you already apply in this job.`})
        }

        const updatedJob = {
            ...job,
            applyCount: BigInt(job.applyCount) + BigInt(1),
            applies: [...job.applies, user.id],
            updatedAt: Some(ic.time())
        }

        jobs.insert(job.id, updatedJob)
        return Ok(updatedJob)
    }),

})
